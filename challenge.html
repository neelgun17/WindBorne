<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WindBorne Constellation â€” 24h Live Map</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 320px 1fr; grid-template-rows: auto 1fr; height: 100%; }
    header { grid-column: 1 / -1; padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display:flex; gap:12px; align-items:center; }
    header h1 { font-size: 18px; margin: 0; }
    #sidebar { border-right: 1px solid #e5e7eb; padding: 12px; overflow: auto; }
    #map { width: 100%; height: 100%; }
    .stat { display: grid; grid-template-columns: 1fr auto; padding: 8px 0; border-bottom: 1px dashed #eee; }
    .pill { display:inline-block; padding:2px 8px; border-radius:9999px; background:#eef2ff; font-size:12px; }
    .row { margin: 8px 0; }
    .small { color:#6b7280; font-size:12px; }
    .btn { background:#111827; color:white; border:0; padding:8px 10px; border-radius:10px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:default; }
    .legend { position:absolute; bottom:12px; right:12px; background:white; border:1px solid #e5e7eb; border-radius:10px; padding:8px 10px; font-size:12px; box-shadow: 0 4px 12px rgba(0,0,0,.06); }
    .bar { height:6px; background: linear-gradient(90deg, #22c55e, #eab308, #ef4444); border-radius:9999px; }
    .footer { font-size: 12px; color:#6b7280; margin-top: 8px; }
    a { color:#2563eb; text-decoration:none; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>WindBorne Constellation â€” last 24h</h1>
      <span class="pill" id="refreshPill">refreshingâ€¦</span>
      <button class="btn" id="refreshBtn" title="Force refresh">Refresh</button>
    </header>

    <aside id="sidebar">
      <div class="row"><strong>Summary (rolling 24h)</strong></div>
      <div class="stat"><span>Balloons tracked</span><strong id="statBalloons">â€“</strong></div>
      <div class="stat"><span>Total path length</span><strong id="statKm">â€“</strong></div>
      <div class="stat"><span>Median ground speed</span><strong id="statSpeed">â€“</strong></div>
      <div class="stat"><span>Wind alignment &lt; 45Â°</span><strong id="statAlign">â€“</strong></div>
      <div class="stat"><span>Active severe alerts</span><strong id="statAlerts">â€“</strong></div>
      <div class="stat"><span>Balloons in alerts</span><strong id="statAlertBalloons">â€“</strong></div>
      <div class="row">
        <div class="small">Tracks are colored by perâ€‘segment ground speed (green â†’ fast, red â†’ slow). Hover markers for details. Updates every 5 minutes.</div>
      </div>
      <div class="row"><strong>Coverage priorities</strong>
        <div class="small" id="recoList">Computingâ€¦</div>
      </div>

      <div class="row"><strong>Data Sources</strong>
        <div class="small">
          â€¢ WindBorne live snapshots: <code>a.windbornesystems.com/treasure/00..23.json</code><br/>
          â€¢ External: <a href="https://open-meteo.com/" target="_blank" rel="noreferrer">Openâ€‘Meteo</a> hourly wind at 10m (no key)<br/>
          â€¢ Extreme alerts: <a href="https://www.weather.gov/documentation/services-web-api" target="_blank" rel="noreferrer">NOAA Weather API</a> (US + territories)
        </div>
        <div class="small" id="log" style="margin-top:6px; padding:6px; border:1px dashed #e5e7eb; border-radius:8px; background:#fafafa; max-height:120px; overflow:auto;">
          status: initializingâ€¦
        </div>
      </div>

      <div class="row"><strong>Export</strong>
        <div class="small"><button class="btn" id="exportBtn">Download GeoJSON</button></div>
      </div>

      <div class="footer">Map Â© <a href="https://www.openstreetmap.org/" target="_blank" rel="noreferrer">OSM</a> contributors â€¢ Tiles Â© OSM | Built for WindBorne challenge</div>
    </aside>

    <main id="map"></main>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    // --- Utilities ---
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const toRad = (d) => d * Math.PI / 180;
    const haversineKm = (a, b) => {
      const R = 6371; // km
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const h = Math.sin(dLat/2)**2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(h));
    };
    const bearingDeg = (a, b) => {
      const y = Math.sin(toRad(b.lon - a.lon)) * Math.cos(toRad(b.lat));
      const x = Math.cos(toRad(a.lat))*Math.sin(toRad(b.lat)) - Math.sin(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.cos(toRad(b.lon - a.lon));
      const brng = Math.atan2(y, x) * 180/Math.PI;
      return (brng + 360) % 360;
    };

    const LOCAL_PROXY = 'http://127.0.0.1:8787';
    const ALERTS_API = 'https://api.weather.gov/alerts/active?status=actual&message_type=alert&severity=Severe,Extreme&certainty=Observed,Likely&limit=200';
    const WIND_TILE_SIZE_DEG = 0.5; // quantize coordinates to reuse Open-Meteo responses
    const WIND_CACHE_TTL_MS = 30 * 60 * 1000;
    const WIND_MAX_PER_RENDER = 120;
    const meteoCache = new Map();
    const COVERAGE_TILE_DEG = 10;
    const COVERAGE_MAX_GAP_H = 6;
    const COVERAGE_MIN_BALLOONS = 3;

    // Try to coerce a WindBorne record into {id, lat, lon, ts}
    function normalizeRecord(rec) {
      if (!rec || typeof rec !== 'object') return null;
      const id = rec.id || rec.name || rec.unit_id || rec.serial || rec.balloon_id || null;
      const lat = rec.lat ?? rec.latitude ?? rec.Latitude ?? null;
      const lon = rec.lon ?? rec.longitude ?? rec.Longitude ?? null;
      let ts = rec.ts || rec.timestamp || rec.time || rec.updated_at || null;
      const alt = rec.alt ?? rec.altitude ?? rec.Altitude ?? null;
      if (typeof ts === 'string') {
        const t = Date.parse(ts);
        if (!Number.isNaN(t)) ts = t; else ts = null;
      }
      if (typeof ts === 'number' && ts < 2e12) { ts = ts * 1000; } // seconds â†’ ms
      if (lat == null || lon == null) return null;
      return { id, lat: +lat, lon: +lon, ts: ts ?? Date.now(), syntheticId: !id, alt: alt != null ? +alt : null };
    }

    // Attempt to interpret any snapshot shape into normalized points
    function coercePointsFromAny(blob, hourAge) {
      const out = [];
      const ts = Date.now() - hourAge * 3600 * 1000;
      const pushPt = (lat, lon, opts = {}) => {
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
        const { id = null, synthetic = false, alt = null } = opts;
        out.push({ id, lat: +lat, lon: +lon, ts, syntheticId: synthetic || !id, alt: alt != null ? +alt : null });
      };
      const isLat = (x) => typeof x === 'number' && Math.abs(x) <= 90;
      const isLon = (x) => typeof x === 'number' && Math.abs(x) <= 180;

      if (Array.isArray(blob)) {
        if (blob.length && typeof blob[0] === 'number') {
          for (let i = 0; i + 1 < blob.length; i += 2) {
            const a = +blob[i], b = +blob[i+1];
            if (isLat(a) && isLon(b)) pushPt(a, b, { synthetic: true });
            else if (isLat(b) && isLon(a)) pushPt(b, a, { synthetic: true });
          }
          return out;
        }
        if (blob.length && Array.isArray(blob[0])) {
          for (const tuple of blob) {
            if (!Array.isArray(tuple) || tuple.length < 2) continue;
            const a = +tuple[0], b = +tuple[1];
            const alt = tuple.length >= 3 ? +tuple[2] : null;
            if (isLat(a) && isLon(b)) pushPt(a, b, { synthetic: true, alt });
            else if (isLat(b) && isLon(a)) pushPt(b, a, { synthetic: true, alt });
          }
          return out;
        }
        for (const rec of blob) {
          const norm = normalizeRecord(rec);
          if (norm) out.push({ ...norm, ts: norm.ts ?? ts });
        }
        return out;
      }

      if (blob && typeof blob === 'object') {
        const entries = Object.entries(blob);
        if (entries.length && Array.isArray(entries[0][1])) {
          for (const [key, arr] of entries) {
            if (!Array.isArray(arr)) continue;
            let idx = 0;
            for (const val of arr) {
              if (Array.isArray(val) && val.length >= 2) {
                const a = +val[0], b = +val[1];
                const id = key && typeof key === 'string' ? key : null;
                const alt = val.length >= 3 ? +val[2] : null;
                if (isLat(a) && isLon(b)) pushPt(a, b, { id, synthetic: !id, alt });
                else if (isLat(b) && isLon(a)) pushPt(b, a, { id, synthetic: !id, alt });
              } else if (val && typeof val === 'object') {
                const norm = normalizeRecord(val);
                if (norm) {
                  const finalId = norm.id || key || null;
                  out.push({ ...norm, id: finalId, syntheticId: !finalId, ts: norm.ts ?? ts });
                }
              }
              idx++;
            }
          }
          return out;
        }
        if (Array.isArray(blob.lats) && Array.isArray(blob.lons)) {
          const n = Math.min(blob.lats.length, blob.lons.length);
          for (let i = 0; i < n; i++) pushPt(blob.lats[i], blob.lons[i], { synthetic: true });
          return out;
        }
        const norm = normalizeRecord(blob);
        if (norm) out.push({ ...norm, ts: norm.ts ?? ts });
      }
      return out;
    }

    async function fetchJsonRobust(url) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        const text = await res.text();
        try {
          return JSON.parse(text);
        } catch (e) {
          const safe = text
            .replace(/,\s*]/g, "]")
            .replace(/,\s*}/g, "}")
            .replace(/[^\{\}\[\]\:,"0-9\-\+\.a-zA-Z_\s]/g, '');
          try { return JSON.parse(safe); } catch { return null; }
        }
      } catch (e) { return null; }
    }

    async function fetchWithFallback(urls) {
      for (const u of urls) {
        const j = await fetchJsonRobust(u);
        if (j) return j;
      }
      return null;
    }

    async function fetchWindBorne24h() {
      const perHour = [];
      const failures = [];
      for (let h = 0; h <= 23; h++) {
        const hh = h.toString().padStart(2, '0');
        const direct = `https://a.windbornesystems.com/treasure/${hh}.json`;
        const proxy1 = `https://r.jina.ai/http://a.windbornesystems.com/treasure/${hh}.json`;
        const proxy2 = `https://r.jina.ai/https://a.windbornesystems.com/treasure/${hh}.json`;
        const blob = await fetchWithFallback([
          `${LOCAL_PROXY}/treasure/${hh}.json`,
          proxy1,
          proxy2,
          direct
        ]);
        // Be polite to proxies to avoid 429; bump to ~0.5s between requests
        await sleep(500);
        if (!blob) { failures.push(hh); continue; }
        const pts = coercePointsFromAny(blob.data || blob.items || blob, h).map(p => ({ ...p, ageH: h }));
        perHour[h] = pts;
      }
      const byId = stitchTracks(perHour);
      const log = document.getElementById('log');
      if (log) {
        if (failures.length) log.textContent = `loaded with fallbacks; missing hours: ${failures.join(', ')}`;
        else log.textContent = 'loaded ok';
      }
      return byId;
    }

    function stitchTracks(hours) {
      const MAX_GAP_MS = 1 * 3600 * 1000;
      const MAX_DIST_KM = 150;
      const MAX_SPEED_KMH = 50;
      const MAX_ALT_DIFF = 10; // meters? unspecified; treat as heuristic
      const BUCKET_DEG = 3;
      const tracks = new Map();
      let syntheticCounter = 0;
      let lastHourBuckets = new Map();

      const attach = (trackId, pt) => {
        if (!tracks.has(trackId)) tracks.set(trackId, []);
        tracks.get(trackId).push({ ...pt, id: trackId, syntheticId: false });
      };

      const baseBucket = (lat, lon) => {
        const bLat = Math.floor(lat / BUCKET_DEG);
        const bLon = Math.floor(lon / BUCKET_DEG);
        return { bLat, bLon };
      };

      const neighborBuckets = (lat, lon) => {
        const { bLat, bLon } = baseBucket(lat, lon);
        const keys = [];
        for (let dLat = -1; dLat <= 1; dLat++) {
          for (let dLon = -1; dLon <= 1; dLon++) {
            keys.push(`${bLat + dLat}:${bLon + dLon}`);
          }
        }
        return keys;
      };

      for (let h = 0; h < hours.length; h++) {
        const pts = hours[h] || [];
        const currentBuckets = new Map();
        for (const raw of pts) {
          if (!raw || !Number.isFinite(raw.lat) || !Number.isFinite(raw.lon) || !Number.isFinite(raw.ts)) continue;
          const pt = { ...raw };
          const nativeId = pt.id && !pt.syntheticId ? pt.id : null;
          let trackId = nativeId;

          if (!trackId && lastHourBuckets.size) {
            let best = null;
            const targetBuckets = neighborBuckets(pt.lat, pt.lon);
            for (const key of targetBuckets) {
              const bucket = lastHourBuckets.get(key);
              if (!bucket) continue;
              for (const candidate of bucket) {
                const dt = candidate.point.ts - pt.ts;
                if (dt <= 0 || dt > MAX_GAP_MS) continue;
                if (pt.alt != null && candidate.point.alt != null) {
                  const altDiff = Math.abs(pt.alt - candidate.point.alt);
                  if (altDiff > MAX_ALT_DIFF) continue;
                }
                const dist = haversineKm(candidate.point, pt);
                if (!Number.isFinite(dist) || dist > MAX_DIST_KM) continue;
                const hoursDiff = Math.max(dt / 3600000, 1/60);
                const speed = dist / hoursDiff;
                if (!Number.isFinite(speed) || speed > MAX_SPEED_KMH) continue;
                if (!best || dist < best.dist) best = { dist, trackId: candidate.trackId };
              }
            }
            if (best) trackId = best.trackId;
          }

          if (!trackId) {
            trackId = `track-${syntheticCounter++}`;
          }
          attach(trackId, pt);
          const { bLat, bLon } = baseBucket(pt.lat, pt.lon);
          const bucketKey = `${bLat}:${bLon}`;
          if (!currentBuckets.has(bucketKey)) currentBuckets.set(bucketKey, []);
          currentBuckets.get(bucketKey).push({ trackId, point: { ...pt, id: trackId } });
        }
        lastHourBuckets = currentBuckets;
      }

      for (const [id, arr] of tracks) {
        arr.sort((a,b) => a.ts - b.ts);
        const dedup = [];
        for (const p of arr) {
          const last = dedup[dedup.length - 1];
          if (!last || last.lat !== p.lat || last.lon !== p.lon || last.ts !== p.ts) dedup.push(p);
        }
        tracks.set(id, dedup);
      }
      return tracks;
    }

    async function fetchExtremeEvents() {
      try {
        const res = await fetch(ALERTS_API, {
          headers: {
            'Accept': 'application/geo+json',
            'User-Agent': 'WindBorneChallengeMap/1.0 (demo@windborne.local)'
          },
          cache: 'no-store'
        });
        if (!res.ok) return [];
        const data = await res.json();
        return Array.isArray(data.features) ? data.features : [];
      } catch (e) {
        console.warn('alerts fetch failed', e);
        return [];
      }
    }

    function prepareAlertShapes(features, layer) {
      layer.clearLayers();
      const shapes = [];
      let fallbackIdx = 0;
      for (const feat of features) {
        if (!feat || !feat.geometry) continue;
        const props = feat.properties || {};
        const severity = props.severity || 'unknown';
        const title = props.event || props.headline || 'Alert';
        const polygons = [];
        if (feat.geometry.type === 'Polygon') polygons.push(feat.geometry.coordinates);
        else if (feat.geometry.type === 'MultiPolygon') polygons.push(...feat.geometry.coordinates);
        for (const rings of polygons) {
          if (!rings || !rings.length) continue;
          const outer = rings[0];
          if (!outer || outer.length < 4) continue;
          const latlngs = outer.map(([lon, lat]) => [lat, lon]);
          const holeRings = rings.slice(1);
          const color = severity === 'Extreme' ? '#b91c1c' : '#f97316';
          L.polygon(latlngs, {
            color,
            weight: 2,
            fillOpacity: 0.15,
            opacity: 0.8
          }).bindTooltip(
            `<strong>${title}</strong><br/>Severity: ${severity}<br/>Areas: ${props.areaDesc || 'n/a'}`,
            { sticky: true }
          ).addTo(layer);
          shapes.push({
            id: feat.id || props.id || `alert-${fallbackIdx++}`,
            title,
            severity,
            outer,
            holes: holeRings
          });
        }
      }
      return shapes;
    }

    function pointInPolygon(point, polygon) {
      if (!polygon || polygon.length < 3) return false;
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        const intersects = ((yi > point[1]) !== (yj > point[1])) &&
          (point[0] < (xj - xi) * (point[1] - yi) / ((yj - yi) || 1e-9) + xi);
        if (intersects) inside = !inside;
      }
      return inside;
    }

    function pointInAlert(point, alert) {
      if (!pointInPolygon(point, alert.outer)) return false;
      if (alert.holes && alert.holes.length) {
        for (const hole of alert.holes) {
          if (pointInPolygon(point, hole)) return false;
        }
      }
      return true;
    }

    function findAlertHit(point, alerts) {
      for (const alert of alerts) {
        if (pointInAlert(point, alert)) return alert;
      }
      return null;
    }

    function coverageCellForPoint(lat, lon) {
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      const latIdx = Math.floor((lat + 90) / COVERAGE_TILE_DEG);
      const lonIdx = Math.floor((lon + 180) / COVERAGE_TILE_DEG);
      return {
        key: `${latIdx}:${lonIdx}`,
        latIdx,
        lonIdx
      };
    }

    function centroidOfRing(ring) {
      if (!ring || ring.length < 3) return null;
      let area = 0, cx = 0, cy = 0;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const [x0, y0] = ring[j];
        const [x1, y1] = ring[i];
        const cross = x0 * y1 - x1 * y0;
        area += cross;
        cx += (x0 + x1) * cross;
        cy += (y0 + y1) * cross;
      }
      area *= 0.5;
      if (Math.abs(area) < 1e-6) {
        const sum = ring.reduce((acc, [x, y]) => [acc[0] + x, acc[1] + y], [0,0]);
        return { lon: sum[0]/ring.length, lat: sum[1]/ring.length };
      }
      cx /= (6 * area);
      cy /= (6 * area);
      return { lon: cx, lat: cy };
    }

    function updateRecommendations(coverageCells, alertShapes, alertCoverage, coverageLayer) {
      const suggestions = [];
      const now = Date.now();
      const tileSize = COVERAGE_TILE_DEG;
      for (const cell of coverageCells.values()) {
        const latMin = -90 + cell.latIdx * tileSize;
        const lonMin = -180 + cell.lonIdx * tileSize;
        const centerLat = latMin + tileSize / 2;
        const centerLon = lonMin + tileSize / 2;
        const gapH = cell.latest ? (now - cell.latest) / 3600000 : Infinity;
        if (gapH > COVERAGE_MAX_GAP_H || cell.count < COVERAGE_MIN_BALLOONS) {
          suggestions.push({
            type: 'coverage',
            priority: gapH + (COVERAGE_MIN_BALLOONS - Math.min(cell.count, COVERAGE_MIN_BALLOONS)),
            lat: centerLat,
            lon: centerLon,
            latMin,
            lonMin,
            gapH,
            count: cell.count
          });
        }
      }

      for (const alert of alertShapes) {
        if (alertCoverage.covered.has(alert.id)) continue;
        const centroid = centroidOfRing(alert.outer);
        if (!centroid) continue;
        suggestions.push({
          type: 'alert',
          priority: 100,
          lat: centroid.lat,
          lon: centroid.lon,
          title: alert.title,
          severity: alert.severity
        });
      }

      suggestions.sort((a, b) => b.priority - a.priority);
      const top = suggestions.slice(0, 5);

      const list = document.getElementById('recoList');
      if (!top.length) {
        list.textContent = 'Coverage looks good across the monitored regions.';
      } else {
        list.innerHTML = top.map(s => {
          if (s.type === 'alert') {
            return `<div>ðŸš¨ ${s.title || 'Severe alert'}<br/><span class="small">No balloons sampling this area yet.</span></div>`;
          }
          return `<div>ðŸ“¡ ${s.lat.toFixed(1)}Â°, ${s.lon.toFixed(1)}Â°<br/><span class="small">${s.count} balloon(s), last sample ${s.gapH === Infinity ? 'never' : `${s.gapH.toFixed(1)}h`} ago.</span></div>`;
        }).join('');
      }

      for (const s of top) {
        if (s.type === 'coverage') {
          const bounds = [
            [s.latMin, s.lonMin],
            [s.latMin + tileSize, s.lonMin + tileSize]
          ];
          L.rectangle(bounds, {
            color: '#fbbf24',
            weight: 1,
            fillOpacity: 0.1,
            dashArray: '4 4'
          }).bindTooltip(
            `Low coverage<br/>Last sample: ${s.gapH === Infinity ? 'none' : `${s.gapH.toFixed(1)}h ago`}<br/>Balloons: ${s.count}`,
            { sticky: true }
          ).addTo(coverageLayer);
        } else if (s.type === 'alert') {
          L.circleMarker([s.lat, s.lon], {
            radius: 6,
            color: '#f97316',
            fillColor: '#f97316',
            fillOpacity: 0.9
          }).bindTooltip(
            `Alert: ${s.title || 'Severe'}<br/>Need balloon coverage.`,
            { sticky: true }
          ).addTo(coverageLayer);
        }
      }
    }

    async function fetchOpenMeteo(lat, lon, budget) {
      const quantizedLat = Math.round(lat / WIND_TILE_SIZE_DEG) * WIND_TILE_SIZE_DEG;
      const quantizedLon = Math.round(lon / WIND_TILE_SIZE_DEG) * WIND_TILE_SIZE_DEG;
      const cacheKey = `${quantizedLat.toFixed(2)},${quantizedLon.toFixed(2)}`;
      const cached = meteoCache.get(cacheKey);
      if (cached && (Date.now() - cached.at) < WIND_CACHE_TTL_MS) {
        return cached.data;
      }
      if (budget) {
        if (budget.remaining <= 0) {
          budget.skipped = true;
          return null;
        }
        budget.remaining -= 1;
      }
      // Hourly 10m wind; Openâ€‘Meteo does not require an API key
      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.searchParams.set('latitude', quantizedLat.toFixed(4));
      url.searchParams.set('longitude', quantizedLon.toFixed(4));
      url.searchParams.set('hourly', 'wind_speed_10m,wind_direction_10m');
      url.searchParams.set('past_days', '1');
      url.searchParams.set('forecast_days', '1');
      url.searchParams.set('timezone', 'UTC');
      // The API returns arrays aligned to hourly timestamps in UTC
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        const j = await res.json();
        meteoCache.set(cacheKey, { at: Date.now(), data: j });
        return j;
      } catch { return null; }
    }

    function colorForSpeed(kmh) {
      // Map 0..120 km/h to green â†’ yellow â†’ red
      const clamped = Math.max(0, Math.min(120, kmh));
      const t = clamped / 120; // 0..1
      const r = Math.round(255 * (t < 0.5 ? t*2 : 1));
      const g = Math.round(255 * (t < 0.5 ? 1 : (1-(t-0.5)*2)));
      return `rgb(${r},${g},80)`;
    }

    // --- Map setup ---
    const map = L.map('map');
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const layerGroup = L.layerGroup().addTo(map);
    const alertsLayer = L.layerGroup().addTo(map);
    const coverageLayer = L.layerGroup().addTo(map);
    const legend = L.control({ position: 'bottomright' });
    legend.onAdd = function() {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '<div><strong>Ground speed</strong></div><div class="bar"></div><div class="small">0 â†’ 120+ km/h</div>';
      return div;
    };
    legend.addTo(map);

    function fmtKm(n){ return `${n.toFixed(1)} km`; }
    function fmtKmh(n){ return `${n.toFixed(0)} km/h`; }

    async function render() {
      document.getElementById('refreshPill').textContent = 'refreshingâ€¦';
      document.getElementById('refreshBtn').disabled = true;
      layerGroup.clearLayers();
      alertsLayer.clearLayers();
      coverageLayer.clearLayers();

      const [byId, alertFeatures] = await Promise.all([
        fetchWindBorne24h(),
        fetchExtremeEvents()
      ]);
      const alertShapes = prepareAlertShapes(alertFeatures, alertsLayer);
      const bounds = [];
      let totalKm = 0;
      let speeds = [];
      let aligned = 0, segs = 0;
      const meteoBudget = { remaining: WIND_MAX_PER_RENDER, skipped: false };
      const alertCoverage = { total: alertShapes.length, balloons: 0, covered: new Set(), hits: new Map() };
      const coverageCells = new Map();

        for (const [id, pts] of byId) {
          const cellsTouched = new Set();
          if (pts.length < 2) continue;
        const label = id ?? 'unknown';
        const latlngs = pts.map(p => [p.lat, p.lon]);
        latlngs.forEach(ll => bounds.push(ll));

        // Segment speeds and colors
        const segColors = [];
        const speedsKmh = [];
        for (let i=1; i<pts.length; i++) {
          const a = pts[i-1], b = pts[i];
          const dtH = Math.max( (b.ts - a.ts) / 3600000, 1/60 );
          const dKm = haversineKm(a, b);
          const v = dKm / dtH;
          totalKm += dKm;
          speeds.push(v);
          speedsKmh.push(v);
          segColors.push(colorForSpeed(v));
        }

        // Draw polyline with gradient-ish segments
        for (let i=1; i<latlngs.length; i++) {
          L.polyline([latlngs[i-1], latlngs[i]], { color: segColors[i-1], weight: 4, opacity: 0.9 }).addTo(layerGroup);
        }

        for (const p of pts) {
          const cell = coverageCellForPoint(p.lat, p.lon);
          if (!cell) continue;
          const key = cell.key;
          if (!coverageCells.has(key)) coverageCells.set(key, { ...cell, count: 0, latest: 0 });
          const node = coverageCells.get(key);
          if (!cellsTouched.has(key)) {
            node.count += 1;
            cellsTouched.add(key);
          }
          if (p.ts > node.latest) node.latest = p.ts;
        }

        const last = pts[pts.length-1];
        // Query Openâ€‘Meteo for the last point's wind (limited & cached)
        const meteo = await fetchOpenMeteo(last.lat, last.lon, meteoBudget);
        let windStr = meteoBudget.skipped ? 'rate limited' : 'â€”';
        let alignStr = '';
        const alertHit = findAlertHit([last.lon, last.lat], alertShapes);
        if (alertHit) {
          alertCoverage.balloons++;
          alertCoverage.covered.add(alertHit.id);
          const prev = alertCoverage.hits.get(alertHit.id) || 0;
          alertCoverage.hits.set(alertHit.id, prev + 1);
        }
        if (meteo && meteo.hourly && meteo.hourly.time) {
          // Match nearest hour to last.ts
          const idx = meteo.hourly.time.findIndex(t => Math.abs(Date.parse(t+'Z') - last.ts) < 90*60*1000);
          const wspd = idx>=0 ? meteo.hourly.wind_speed_10m[idx] : null;
          const wdir = idx>=0 ? meteo.hourly.wind_direction_10m[idx] : null;
          if (wspd != null && wdir != null && pts.length >= 2) {
            windStr = `${wspd.toFixed(0)} km/h @ ${wdir.toFixed(0)}Â°`;
            const brg = bearingDeg(pts[pts.length-2], last);
            const delta = Math.min(Math.abs(brg - wdir), 360 - Math.abs(brg - wdir));
            if (!Number.isNaN(delta)) {
              segs++; if (delta < 45) aligned++;
              alignStr = `\nAlignment Î”: ${delta.toFixed(0)}Â°`;
            }
          }
        }

        const marker = L.circleMarker([last.lat, last.lon], { radius: 6, color: '#111827', weight: 2, fillColor: '#22c55e', fillOpacity: .9 })
          .bindTooltip(
            `<strong>${label}</strong><br/>Pts: ${pts.length}<br/>Last: ${new Date(last.ts).toUTCString()}<br/>Wind (10m): ${windStr}${alignStr}${alertHit ? `<br/>Alert: ${alertHit.title}` : ''}`,
            { direction: 'top', sticky: true }
          )
          .addTo(layerGroup);
        if (alertHit) {
          marker.setStyle({ fillColor: '#ef4444' });
        }
      }

      if (bounds.length) map.fitBounds(bounds, { padding: [20,20] }); else map.setView([20,0], 2);

      // Stats
      const med = (arr) => arr.sort((a,b)=>a-b)[Math.floor(arr.length/2)] ?? 0;
      document.getElementById('statBalloons').textContent = Array.from(byId.keys()).length;
      document.getElementById('statKm').textContent = fmtKm(totalKm);
      document.getElementById('statSpeed').textContent = speeds.length ? fmtKmh(med(speeds)) : 'â€“';
      document.getElementById('statAlign').textContent = segs ? `${Math.round(100*aligned/segs)}%` : 'â€“';
      document.getElementById('statAlerts').textContent = alertShapes.length
        ? `${alertCoverage.covered.size}/${alertShapes.length}`
        : '0';
      document.getElementById('statAlertBalloons').textContent = alertCoverage.balloons;
      updateRecommendations(coverageCells, alertShapes, alertCoverage, coverageLayer);

      document.getElementById('refreshPill').textContent = 'live';
      document.getElementById('refreshBtn').disabled = false;
      return byId;
    }

    async function exportGeoJSON(byId) {
      const features = [];
      for (const [id, pts] of byId) {
        const label = id ?? 'unknown';
        features.push({
          type: 'Feature',
          properties: { id: label, points: pts.length },
          geometry: { type: 'LineString', coordinates: pts.map(p => [p.lon, p.lat]) }
        });
        const last = pts[pts.length-1];
        features.push({
          type: 'Feature',
          properties: { id: label, kind: 'last' },
          geometry: { type: 'Point', coordinates: [last.lon, last.lat] }
        });
      }
      const blob = new Blob([JSON.stringify({ type:'FeatureCollection', features }, null, 2)], { type: 'application/geo+json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'windborne_24h.geojson'; a.click();
      URL.revokeObjectURL(url);
    }

    let lastData = null;
    document.getElementById('refreshBtn').addEventListener('click', async () => { lastData = await render(); });
    document.getElementById('exportBtn').addEventListener('click', () => { if (lastData) exportGeoJSON(lastData); });

    // Auto refresh every 5 minutes
    (async function loop(){ lastData = await render(); setInterval(render, 5*60*1000); })();
  </script>
</body>
</html>
